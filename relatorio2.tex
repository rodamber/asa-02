\documentclass[12pt, a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{authblk}
\usepackage{enumitem}

\setlist[description]{labelindent=1cm}

\title{\textbf{Relatório do 1º projecto de ASA}}
\author{Rodrigo André Moreira Bernardo \\ ist178942}
\affil{Instituto Superior Técnico}

\date{\today}


\begin{document}
\maketitle

\section{O Problema}

\subsection{Introdução}
\paragraph{}
A empresa Coelho e Caracol, Lda.\ faz transporte de mercadorias. O Sr. Coelho
trata do transporte, enquanto o Sr. Caracol fica no escritório a fazer o
planeamento das rotas, sendo que cada uma consiste numa sequência de
localidades. Cada conexão entre localidades tem a si associada um valor de
perda, que resulta de subtrair a receita ao custo.

\subsection{Objectivo}
\paragraph{}
Dado um input que identifique a sede da empresa, o número de localidades e as
conexões entre si, assim como o valor de perda de cada uma, determinar a perda
mínima desde a sede até cada localidade. O output deverá indicar para cada
localidade o respectivo valor de perda. No entanto, caso uma localidade seja
impossível de alcançar, então o seu valor de perda deve ser "U"\ e, caso seja
impossível definir essa perda, então dizemos que o seu valor de perda é "I".

\section{A Solução}
\paragraph{}
O programa foi implementado em linguagem C.  A solução passa por executar o
algoritmo de Bellman-Ford para caminhos mais curtos sobre um grafo, \textit{G},
cujos vértices representam as localidades e cujas arestas representam as
conexões entre as localidades. No último ciclo do algoritmo, caso se verifique
que ainda seria possível relaxar uma determinada aresta (\textit{u},
\textit{v}), ou seja, se existir ciclos negativos, então é feita uma procura em
largura primeiro (BFS) com início em \textit{v}, marcando a estimativa de
caminho mais curto de cada vértice visitado a $-\infty$, o que significa que é
um vértice "I".

\subsection{A Representação}
\paragraph{}
Cada localidade é representada por um inteiro. A representação do grafo é em
listas de adjacências. Mais pormenorizadamente, um grafo é uma estrutura
composta por um vector de ponteiros para vértices e por um inteiro que indica o
seu número de vértices (linhas 57-60). Cada vértice é uma estrutura com vários
elementos, entre eles uma chave que o representa e um ponteiro para uma aresta
adjacente (linhas 9-20). Cada aresta depois tem um ponteiro para a aresta
adjacente seguinte (linhas 26-34). Propriedades características de cada
algoritmo (como estimativa de caminho mais curto no algoritmo de Bellman-Ford ou
cor na BFS) estão nas estruturas dos vértices e das arestas (em vez de haverem
vectores para cada propriedade) para ser mais fácil aceder a essas propriedades
nas várias partes do programa.
\paragraph{}
Para representar $-\infty$ e $+\infty$, foram utilizados INT\_MIN e INT\_MAX,
respectivamente. Para acomodar esta escolha, foi criada uma função de soma
(linhas 254-258), de forma a evitar \textit{overflows}.

\subsection{O Algoritmo}
\paragraph{}
O algoritmo é uma versão modificada do algoritmo de Bellman-Ford. No entanto,
foram feitas duas optimizações. A primeira passa por terminar o algoritmo caso
tenha havido uma iteração onde não se verificasse relaxamento de arestas. A
segunda passa por, a cada iteração, relaxar apenas arestas cujo vértice da qual
partem tenho visto a sua estimativa de caminho mais curto alterada desde a
última vez que essas arestas foram relaxadas.
\paragraph{}
Em relação à detecção dos vértices "I", é também verificado se a estimativa de
caminho mais curto de cada vértice encontrado não é já $-\infty$.  Se for,
termina-se a BFS (ou nem sequer se inicia), de forma a diminuir o número de
pesquisas redundantes.

\section{Análise Teórica}
\subsection{Avaliação}
\paragraph{}
Sejam \textit{V} e \textit{E} o número de vértices e arestas do grafo,
respectivamente.  O programa começa por ler as duas primeiras linhas do input,
obtendo \textit{N}, o número de localidades, \textit{C}, o número de custos, e
\textit{H}, um inteiro que representa a sede da empresa. Depois inicializa o
grafo com \textit{V=N} vértices, que demora \textit{O(V)}. Ler as linhas
restantes para adicionar as arestas é \textit{O(E)}, tendo em conta que
adicionar uma nova aresta ao grafo é \textit{O(1)}, \textit{E=C}, e considerando
que as operações de ler linhas e alocar memória são \textit{O(1)}. Até agora
temos uma complexidade para o tempo de \textit{O(V + E)}.

\paragraph{}
O algoritmo (modificado) de Bellman-Ford começa por inicializar todos os
vértices, que é \textit{O(V)}. A seguir tem um ciclo com, no máximo,
\textit{V-1} iterações, onde se aplica a operação de relaxar as arestas. No
máximo, todos as arestas são relaxadas. Como relaxar um arco é \textit{O(1)},
temos que o ciclo é \textit{O(VE)}. Depois, se tiverem ocorrido relaxamentos na
iteração \textit{V-1}, o algoritmo verifica se existem ciclos negativos. O
algoritmo de Bellman-Ford garante que após \textit{V-1} iterações de
relaxamentos todos os vértices têm as suas estimativas de caminho mais curto
correctas, a não ser que existam ciclos negativos. Nesta versão, quando se
detectam ciclos negativos é feita uma BFS para atingir todos os vértices que o
ciclo "atinge" e alterar a sua estimativa de caminho mais curto para
$-\infty$. É feita uma BFS para cada ciclo negativo que existir. Cada BFS é
\textit{O(V + E)}.


\section{Análise Experimental}
\paragraph{}

\section{Referências}
\paragraph{}

\end{document}

















